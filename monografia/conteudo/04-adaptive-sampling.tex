\newcommand{\asampling}{\textit{adaptive sampling}}

\chapter{Contagem distinta aproximada: $\asampling$ (1990)}

Este capítulo aborda uma outra solução para o problema da \textit{contagem distinta aproximada}. O 
Capítulo~\ref{lab:flajolet-martin} apresentou o Algoritmo de Flajolet e Martin, que estima o número de elementos 
distintos de um conjunto com erro relativo esperado em torno de $0.78 / \sqrt{m}$. 

O Algoritmo $\asampling$ publicado no artigo ~\citep{adptive:sampling:90} tem um erro relativo esperado de 
aproximadamente $1.20 / \sqrt{m}$. As razões para estudarmos esse algoritmo mesmo que ele apresente um erro relativo 
maior ficarão claras nas próximas seções.

\section{Algoritmo $\asampling$}
\label{lab:chapter:04:01}

Assim como a solução do capítulo anterior, o algoritmo $\asampling$ também se baseia em padrões de bits dos hashes dos 
elementos examinados. Podemos dessa forma, considerar que os elementos que estamos contando são palavras binárias de 
tamanho infinito. 

Enquanto que no Algoritmo \ref{prog:flajolet-martin++}, estávamos interessados na \textbf{aparição} de um elemento com 
prefixo da forma $0^*1$, no Algoritmo $\asampling$, queremos saber a \textbf{quantidade} de elementos com um certo 
prefixo $0^*1$.

Nesse sentido, vamos manter um contador $\delta$ cujo valor inicialmente é zero, e uma lista que armazena elementos com 
prefixo $0^{\delta}1$. Para cada elemento examinado, inserimos ele na lista se o prefixo dele for da forma $0^{\delta}$.
Quando essa lista tiver mais que $m$ elementos, incrementamos $\delta$ em 1 e passamos a manter 
somente elementos com prefixo $0^{\delta + 1}1$.

Agora, suponha que em um dado momento do algoritmo, a lista tenha tamanho $l$ e estamos mantendo somente elementos com 
prefixos $0^{\delta}1$. A probabilidade de um elemento ter um prefixo dessa forma é $1 / 2^{\delta}$ e consequentemente,
esperamos que a cada $2^{\delta}$ itens, pelo menos um item tenha um prefixo desse formato. Assim, se nossa lista tem
$l$ elementos com prefixo $0^{\delta}$, então devemos ter examinado pelo menos $2^{\delta} l$ itens, e este valor é 
justamente a estimativa para a quantidade de valores distintos.

O Algoritmo \proc{AdaptiveSampling} recebe um conjunto $\Mbb$ com $n$ elementos distintos e um parâmetro $m$, que está 
relacionado com o consumo de memória do algoritmo e sua precisão. O algoritmo usa uma função de hash $h$ para mapear os 
elementos de $\Mbb$ no intervalo $[0, 2^L - 1]$, em que $L$ é a quantidade de bits necessária para se conseguir fazer 
esse mapeamento sem colisões. E o algoritmo devolve um estimador~$\hat{n}$ para $n$ da forma $2^{\delta} l$, em que $l$ 
e $\delta$ indicam que estão sendo armazenados $l$ elementos cujos prefixos tem formato $0^{\delta}1$.

\begin{codebox}
  \Procname{$\proc{AdaptiveSampling}(\Mbb, m)$}
  \li $LIST \gets \emptyset$
  \li $\delta \gets 0$
  \li \For cada $x$ em $\Mbb$ 
  \li    \Do 
         \If $0^{\delta}1$ é prefixo de $h(x)$ \textbf{e} $h(x) \not\in LIST$
  \li             \Then $LIST \gets LIST \cup \{ h(x) \}$
         \End
  \li    \While $|LIST| > m$
  \li    \Do
         $\delta \gets \delta + 1$
  \li    $TEMPLIST \gets \emptyset$
  \li    \For cada $y$ em $LIST$
  \li    \Do
            \If $0^{\delta}1$ é prefixo de $h(y)$
  \li       \Then $TEMPLIST \gets TEMPLIST \cup \{ h(y) \}$
            \End
         \End
  \li    $LIST \gets TEMPLIST$
         \End 
      \End
  \li
  \Return $2^{\delta} |LIST|$   
  \End
\end{codebox}