\chapter{Contagem distinta aproximada: Flajolet-Martin(1985)}
\label{lab:flajolet-martin}

\section{O Problema}

\begin{quote}
  \textbf{Contagem Distinta:} Dado um conjunto $\mathbb{M}$, \textbf{encontrar} quantos elementos \textit{distintos}
  $\mathbb{M}$ possui.
\end{quote}

Uma solução para a \textbf{contagem distinta} é inserir cada elemento de $\mathbb{M}$ em uma tabela hash. 
E assim, a quantidade de itens distintos nesse conjunto será o número de elementos nessa tabela.

Note que esse algoritmo consome $\Omega(n)$ de memória, uma vez que, deve-se armazenar cada elemento 
\textbf{pelo menos uma vez} para que seja possível verificar se um item está no conjunto.

Este consumo linear de espaço pode ser um problema quando a quantidade de elementos que precisam ser armazenados é muito grande.
E podem existir aplicações nas quais é necessário manter \textbf{várias} dessas estruturas, como no caso do \textit{Redis}, em
que se deseja encontrar quantos usuários distintos visualizararm um publicação ~\citep{Redis}. E para essas situações, é interessante
que o consumo de memória seja muito menor que a quantidade de elementos distintos. Portanto, deve-se abandonar
a exatidão da contagem dos elementos distintos para que se possa diminuir o consumo de espaço.

\begin{quote}
  \textbf{Contagem Distinta Aproximada:} dado um conjunto $\mathbb{M}$, \textbf{estimar} o número de elementos \textit{distintos}
  nesse conjunto.
\end{quote}

Uma das primeiras soluções para a \textbf{contagem distinta aproximada} foi apresentada por \textit{Philippe Flajolet} e 
\textit{Nigel Martin} no artigo ~\citep{flajolet:martin:85}.
A motivação para o desenvolvimento desse algoritmo foi a otimização de pesquisas em bancos de dados relacionais.
E a identificação do número de elementos distintos em uma coluna era a principal dificuldade nesse processo.

\section{Algoritmo de Flajolet-Martin}
\label{sec:flajolet-martin:algorithm}

O \textbf{algoritmo de Flajolet-Martin} utiliza uma função de hash $h$ que mapeia uniformemente cada elemento do conjunto $\mathbb{M}$
para um número inteiro entre $0$ e $2^L-1$, em que $L$ é a quantidade necessária de bits para mapear todas as entradas de $\mathbb{M}$
(na prática, este valor é $32$ ou $64$).
Assim, para cada $x_i \in \mathbb{M}$, será calculado um inteiro $y_i \coloneqq h(x_i)$. Note que $y_i$ pode ser visto como 
uma palavra binária aleatória de $L$ bits em que cada bit é gerado independentemente com probabilidade $\frac{1}{2}$.
E o algoritmo é baseado na frequência das aparições dos prefixos dessas palavras aleatórias.

Então, suponha que palavras binárias aleatórias de $L$ bits estejam sendo geradas. Espera-se que a cada \textbf{2} palavras, pelo menos uma comece
com \textbf{1}. E que a cada \textbf{4} palavras, pelo menos uma deva ter o prefixo \textbf{01}. Assim, a cada $\mathbf{2^k}$ palavras, espera-se
que pelo menos uma palavra comece com $\mathbf{0^{k-1}1}$. Por outro lado, caso o prefixo $0^{k-1}1$ apareça, o esperado é que $2^{k}$ 
items já devam ter sido gerados. 

Dessa forma, o algoritmo mantém a ocorrência dos prefixos de cada $\textit{hash}$ em um vetor $BITMAP[0 \dots L-1]$, de modo que $BITMAP[i] = 1$,
se e somente se, o prefixo $0^i1$ apareceu entre os \textit{hashes} dos elementos de $\mathbb{M}$. 

Note que é necessário mapear cada prefixo para um inteiro entre $0$ e $L - 1$. E para isso, defini-se a função $\rho$ 
que recebe um inteiro e devolve a posição do 1 menos significativo deste inteiro. Então, para um \textit{hash} $y$, suponha que $\rho(y) = k$. Assim, 
o prefixo da representação binária de $y$ é $0^k1$, e $BITMAP[k] = 1$. Um caso especial para essa função é quando o \textit{hash} é zero. Nesta situação,
$\rho(0) = L$.

Por fim, seja $R$ o menor índice tal que $BITMAP[R] = 0$. A estimativa para o número de elementos distintos de $\mathbb{M}$ será $2^R/\phi$, em que, 
$\phi$ é um fator de correção que será discutido em \refeq{sec:flajolet-martin:analysis}.

Segue o pseudocódigo:
\begin{programruledcaption}{
Algoritmo de Flajolet-Martin 
\\ \textbf{Entrada:} conjunto $\mathbb{M}$, função de hash $h$, tamanho $L$ do vetor $BITMAP$ 
\\ \textbf{Saída:} quantidade de elementos distintos de $\mathbb{M}$
\label{prog:flajolet-martin}
}
  \begin{lstlisting}[
    language={[brazilian]pseudocode},
    style=pseudocode,
    style=wider,
    functions={},
    specialidentifiers={},
  ]
      funcao FlajoletMartin($\mathbb{M}$, h, L)
        para i de 0 até L \kw{faça}:
          BITMAP[i] := 0
        fim

        para x $\in$ $\mathbb{M}$ \kw{faça}:
          y := h(x)
          BITMAP[$\rho(y)$] := 1
        fim

        R := 0
        enquanto BITMAP[R] = 1 \kw{faça}:
          R := R + 1
        fim

        devolva $2^R/\phi$
      fim
  \end{lstlisting}
\end{programruledcaption}

\section{Análise do algoritmo}
\label{sec:flajolet-martin:analysis}

Suponha que a quantidade de elementos distintos de $\mathbb{M}$ seja $n$. 
O valor esperado de $R$ definido na seção \refeq{sec:flajolet-martin:algorithm} é aproximadamente $\log_2(\phi n)$,
em que $\phi = 0.77351\dots$ e o desvio padrão de $R$ é em torno de $1.12$. 
Essa seção busca mostrar as etapas da análise do Algoritmo \ref{prog:flajolet-martin} feita por Flajolet e Martin.
Os detalhes da prova podem ser vistos em ~\citep{flajolet:martin:85}.

O primeiro passo é entender que $R$ é uma estimativa para $\lfloor \log_2(n) \rfloor$.
Pelo padrão das aparições dos prefixos dos hashes dos elementos de $\mathbb{M}$, 
espera-se que $BITMAP[0]$ seja acessado aproximadamente $\lfloor \frac{n}{2} \rfloor$ vezes, 
$BITMAP[1]$ aproximadamente $\lfloor \frac{n}{4} \rfloor$ vezes $\dots$
Agora, para $k = \lfloor \log_2(n) \rfloor$, $BITMAP[k]$ deve ser acessado em torno de 
$\lfloor \frac{n}{2^{k+1}} \rfloor = 0$ vezes. Assim, o menor índice $R$ tal que o valor de $BITMAP$ seja zero
é aproximadamente $\lfloor \log_2(n) \rfloor$.

Então, defini-se $R_n$ como sendo a saída do Algoritmo \ref{prog:flajolet-martin} para uma entrada $\mathbb{M}$
com $n$ elementos distintos. Dessa forma, o interesse principal da demonstração é encontrar fórmulas ou estimativas
para:
\begin{itemize}
  \item $p_{n,k} = \mathbb{P}(R_n = k)$: probabilidade de uma saída de \ref{prog:flajolet-martin} ser igual a $k$
  \item $q_{n,k} = \mathbb{P}(R_n \geq k)$: probabilidade de uma saída de \ref{prog:flajolet-martin} 
  ser maior ou igual a $k$
  \item $\mathbb{E}[R_n]$: valor esperado de $R_n$
  \item $\mathbb{V}[R_n]$: variância de $R_n$
\end{itemize}

O primeiro teorema de ~\citep{flajolet:martin:85} mostra uma fórmula \textit{exata} e \textit{discreta} para $q_{n,k}$. 
A principal idea para encontrar essa fórmula é agrupar as palavras binárias por prefixos da forma $0^k1$.
Assim, defini-se $E_k = \{ x  \ | \ \rho(x) = k \}$, ou seja, $E_k$ é o conjunto de todas as palavras aleatórias com prefixos
iguais a $0^k1$. Da mesma forma, defini-se $K_k = \{ x \ | \ \rho(x) \geq k \}$. Em seguida, as diferentes entradas $\mathbb{M}$
com $n$ elementos distintos são representadas por um polinômio:
\[ P_k^{(n)} = (E_0 + E_1 + \dots + E_{k-1} + K_k)^n .\]

O próximo passo é tentar expandir esse polinômio usando \textit{inclusão e exclusão}, 
e associar uma medida probabilidade para $E_0, E_1, \dots, E_{k-1}, K_k$. E a prova deste teorema termina encontrando uma relação entre $q_{n,k}$
e esta expansão de polinômio.

Em seguida, o Teorema 2 apresenta aproximações de $q_{n,k}$ para diferentes intervalos de $k$.
E a consequência deste teorema é a existência de uma distribuição limitante para a distribuição
de probabilidade de $R_n$ conforme $n$ cresce. Dessa forma, obtém-se uma fórmula \textit{aproximada} e \textit{contínua}
para $q_{n,k}$:
\[ q_{n,k} \approx \psi(\frac{n}{2^k}) \]

em que, $\psi(x) = \prod_{j \geq 0} (1 - e^{-x2^j})$.

Note que por definição, $p_{n,k} = q_{n,k} - q_{n,k+1}$. Assim, pode-se aproximar $p_{n,k}$:
\[ p_{n,k} \approx \psi(\frac{n}{2^k}) - \psi(\frac{n}{2^{k+1}}) \ . \]

O interesse passa a ser, portanto, estimar $\mathbb{E}[R_n]$ a partir dessa fórmula aproximada de $p_{n,k}$,
de maneira que 
\[\mathbb{E}[R_n] = \sum_{k \geq 1} k p_{n,k} \approx \sum_{k \geq 1} k \Big[ \psi \Big( \frac{n}{2^k} \Big) - \psi \Big( \frac{n}{2^{k+1}} \Big) \Big] \ .\]

Desse modo, defini-se a função real $F(x)$ como sendo
\[ F(x) =  \sum_{k \geq 1} k \Big[ \psi \Big( \frac{n}{2^k} \Big) - \psi \Big( \frac{n}{2^{k+1}} \Big) \Big] \ . \]

E o Lema 1 do artigo, afirma que 
\[ \mathbb{E}[R_n] = F(x) + O \Big( \frac{1}{n^{0.49}} \Big) \ , \]
ou seja, que o valor esperado de $R_n$ se aproxima de $F(x)$ conforme $n$ cresce.

Em seguida, o Lema 2 apresenta o resultado da \hyperref[ap:mellin]{transformada de Mellin} de $F(X)$. 
A principal razão para se calcular essa transformação é que se pode expressar a fórmula inversa da transformada de Mellin 
como uma expansão assintótica cujos termos são resíduos da transformada. Assim, o Teorema $3A$ utiliza os Lemas 1 e 2, e o 
Teorema dos Resíduos para afirmar que 
\[ \mathbb{E}[R_n] = \lg (\phi n) + P(\lg n) + o(1) \ , \]
em que, $P(x)$ é a expansão assintótica de $F(x)$ e $\phi = 0.77351\dots$, concluindo a prova que $\mathbb{E}[R_n] \approx \lg (\phi n)$.

A prova para a estimativa de $\mathbb{V}[R_n]$ segue os mesmos passos da prova anterior. Pela definição de \hyperref[ap:variance]{variância},
precisa-se estimar $\mathbb{E}[R_n ^ 2]$. Assim, 
\[ \mathbb{E[R_n ^2]} = \sum_{k=1} k^2 p_{n,k} \approx G(x) \ , \]
em que,
\[ G(x) = \sum_{k=1} k^2 p_{n,k} \ . \]

Dessa forma, encontra-se a transformada de Mellin de $G(x)$ e se analisa a inversa desta transformação para estimar $\mathbb{E}[R_n^2]$.