\chapter{Contagem distinta aproximada: Flajolet-Martin(1985)}
\label{lab:flajolet-martin}

\section{O Problema}

\begin{quote}
  \textbf{Contagem Distinta:} Dado um conjunto $\mathbb{M}$, \textbf{encontrar} quantos elementos \textit{distintos}
  $\mathbb{M}$ possui.
\end{quote}

Uma solução para a \textbf{contagem distinta} é inserir cada elemento de $\mathbb{M}$ em uma tabela hash. 
E assim, a quantidade de itens distintos nesse conjunto será o número de elementos nessa tabela.

Note que esse algoritmo consome $\Omega(n)$ de memória, uma vez que, deve-se armazenar cada elemento 
\textbf{pelo menos uma vez} para que seja possível verificar se um item está no conjunto.

Este consumo linear de espaço pode ser um problema quando a quantidade de elementos que precisam ser armazenados é muito grande.
E podem existir aplicações nas quais é necessário manter \textbf{várias} dessas estruturas, como no caso do \textit{Redis}, em
que se deseja encontrar quantos usuários distintos visualizararm um publicação ~\citep{Redis}. E para essas situações, é interessante
que o consumo de memória seja muito menor que a quantidade de elementos distintos. Portanto, deve-se abandonar
a exatidão da contagem dos elementos distintos para que se possa diminuir o consumo de espaço.

\begin{quote}
  \textbf{Contagem Distinta Aproximada:} dado um conjunto $\mathbb{M}$, \textbf{estimar} o número de elementos \textit{distintos}
  nesse conjunto.
\end{quote}

Uma das primeiras soluções para a \textbf{contagem distinta aproximada} foi apresentada por \textit{Philippe Flajolet} e 
\textit{Nigel Martin} no artigo ~\citep{flajolet:martin:85}.
A motivação para o desenvolvimento desse algoritmo foi a otimização de pesquisas em bancos de dados relacionais.
E a identificação do número de elementos distintos em uma coluna era a principal dificuldade nesse processo.

\section{Algoritmo de Flajolet-Martin}
\label{sec:flajolet-martin:algorithm}

O \textbf{algoritmo de Flajolet-Martin} utiliza uma função de hash $h$ que mapeia uniformemente cada elemento do conjunto $\mathbb{M}$
para um número inteiro entre $0$ e $2^L-1$, em que $L$ é a quantidade necessária de bits para mapear todas as entradas de $\mathbb{M}$
(na prática, este valor é $32$ ou $64$).
Assim, para cada $x_i \in \mathbb{M}$, será calculado um inteiro $y_i \coloneqq h(x_i)$. Note que $y_i$ pode ser visto como 
uma palavra binária aleatória de $L$ bits em que cada bit é gerado independentemente com probabilidade $\frac{1}{2}$.
E o algoritmo é baseado na frequência das aparições dos prefixos dessas palavras aleatórias.

Então, suponha que palavras binárias aleatórias de $L$ bits estejam sendo geradas. Espera-se que a cada \textbf{2} palavras, pelo menos uma comece
com \textbf{1}. E que a cada \textbf{4} palavras, pelo menos uma deva ter o prefixo \textbf{01}. Assim, a cada $\mathbf{2^k}$ palavras, espera-se
que pelo menos uma palavra comece com $\mathbf{0^{k-1}1}$. Por outro lado, caso o prefixo $0^{k-1}1$ apareça, o esperado é que $2^{k}$ 
items já devam ter sido gerados. 

Dessa forma, o algoritmo mantém a ocorrência dos prefixos de cada $\textit{hash}$ em um vetor $BITMAP[0 \dots L-1]$, de modo que $BITMAP[i] = 1$,
se e somente se, o prefixo $0^i1$ apareceu entre os \textit{hashes} dos elementos de $\mathbb{M}$. 

Note que é necessário mapear cada prefixo para um inteiro entre $0$ e $L - 1$. E para isso, defini-se a função $\rho$ 
que recebe um inteiro e devolve a posição do 1 menos significativo deste inteiro. Então, para um \textit{hash} $y$, suponha que $\rho(y) = k$. Assim, 
o prefixo da representação binária de $y$ é $0^k1$, e $BITMAP[k] = 1$. Um caso especial para essa função é quando o \textit{hash} é zero. Nesta situação,
$\rho(0) = L$.

Por fim, seja $R$ o menor índice tal que $BITMAP[R] = 0$. A estimativa para o número de elementos distintos de $\mathbb{M}$ será $2^R/\phi$, em que, 
$\phi$ é um fator de correção que será discutido em \refeq{sec:flajolet-martin:analysis}.

Segue o pseudocódigo:
\begin{programruledcaption}{
Algoritmo de Flajolet-Martin 
\\ \textbf{Entrada:} conjunto $\mathbb{M}$, função de hash $h$, tamanho $L$ do vetor $BITMAP$ 
\\ \textbf{Saída:} quantidade de elementos distintos de $\mathbb{M}$
\label{prog:flajolet-martin}
}
  \begin{lstlisting}[
    language={[brazilian]pseudocode},
    style=pseudocode,
    style=wider,
    functions={},
    specialidentifiers={},
  ]
      funcao FlajoletMartin($\mathbb{M}$, h, L)
        para i de 0 até L \kw{faça}:
          BITMAP[i] := 0
        fim

        para x $\in$ $\mathbb{M}$ \kw{faça}:
          y := h(x)
          BITMAP[$\rho(y)$] := 1
        fim

        R := 0
        enquanto BITMAP[R] = 1 \kw{faça}:
          R := R + 1
        fim

        devolva $2^R/\phi$
      fim
  \end{lstlisting}
\end{programruledcaption}

\section{Análise do algoritmo}
\label{sec:flajolet-martin:analysis}

Suponha que a quantidade de elementos distintos de $\mathbb{M}$ seja $n$. 
O valor esperado de $R$ definido na seção \refeq{sec:flajolet-martin:algorithm} é aproximadamente $\log_2(\phi n)$,
em que $\phi = 0.77351\dots$ e o desvio padrão de $R$ é em torno de $1.12$. 
Essa seção busca mostrar as etapas da análise do Algoritmo \ref{prog:flajolet-martin} feita por Flajolet e Martin.
Os detalhes da prova podem ser vistos em ~\citep{flajolet:martin:85}.

O primeiro passo é entender que $R$ é uma estimativa para $\lfloor \log_2(n) \rfloor$.
Pelo padrão das aparições dos prefixos dos hashes dos elementos de $\mathbb{M}$, 
espera-se que $BITMAP[0]$ seja acessado aproximadamente $\lfloor \frac{n}{2} \rfloor$ vezes, 
$BITMAP[1]$ aproximadamente $\lfloor \frac{n}{4} \rfloor$ vezes $\dots$
Agora, para $k = \lfloor \log_2(n) \rfloor$, $BITMAP[k]$ deve ser acessado em torno de 
$\lfloor \frac{n}{2^{k+1}} \rfloor = 0$ vezes. Assim, o menor índice $R$ tal que o valor de $BITMAP$ seja zero
é aproximadamente $\lfloor \log_2(n) \rfloor$.

Então, defini-se $R_n$ como sendo a saída do Algoritmo \ref{prog:flajolet-martin} para uma entrada $\mathbb{M}$
com $n$ elementos distintos. Dessa forma, o interesse principal da demonstração é encontrar fórmulas ou estimativas
para:
\begin{itemize}
  \item $p_{n,k} = \mathbb{P}(R_n = k)$: probabilidade de uma saída de \ref{prog:flajolet-martin} ser igual a $k$
  \item $q_{n,k} = \mathbb{P}(R_n \geq k)$: probabilidade de uma saída de \ref{prog:flajolet-martin} 
  ser maior ou igual a $k$
  \item $E[R_n]$: valor esperado de $R_n$
  \item $V[R_n]$: variância de $R_n$
\end{itemize}